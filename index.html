<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Mahimahi</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A set of lightweight tools aimed at browser developers, website authors, and Web server developers to produce a usable benchmark for Web transport protocols and browser behaviors.">
    <meta name="author" content="Ravi Netravali <mahimahi@mit.edu>">

    <!-- Le styles -->
    <link href="assets/css/bootstrap.css" rel="stylesheet">
    <link href="assets/css/style.css" rel="stylesheet">
    <link href="assets/css/bootstrap-responsive.css" rel="stylesheet">

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le fav and touch icons -->
    <link rel="shortcut icon" href="assets/ico/favicon.ico">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="assets/ico/apple-touch-icon-57-precomposed.png">

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-30270105-1']);
      _gaq.push(['_trackPageview']);

      (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>

  </head>

  <body data-spy="scroll">

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="#">Mahimahi</a>
          <div class="nav-collapse">
            <ul class="nav">
              <li><a href="#about">About</a></li>
              <li><a href="#getting">Getting Mahimahi</a></li>
              <li><a href="#techinfo">Details</a></li>
              <li><a href="#usage">Examples</a></li>
              <li><a href="#contact">Contact</a></li>
              <li><a href="https://github.com/ravinet/mahimahi">Mahimahi on GitHub</a></li>
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

<div class="container">

<section id="about">
  <div class="hero-unit span10">
    <div class="row">
      <div class="span10">
        <div align="center">
        <h1>Mahimahi</h1>
        <p>A set of lightweight tools aimed at browser developers, website authors, and Web server developers to produce a usable benchmark for Web transport protocols and browser behaviors.</p>
        <p> Mahimahi contains four different tools which can be used to record actual websites and replay them over various emulated link conditions. </p>
        <p>Mahimahi is free software and is available on Ubuntu (version 13.10 or higher). </p>
        </div>
      </div>
    </div>
    <div align="center">
    <p><a class="btn btn-primary btn-large" href="#getting">Getting Mahimahi &raquo;</a>
    </div>
  </div>

  <div id="features">
  <div class="row-fluid">
      <div class="feature span3">
        <h2 class="callout">Record and replay actual websites</h2>
        <p>Using Mahimahi's recordshell, you can completely record
        and store real websites. Recordshell captures all objects required
        to load a given Web page. Recorded sites can then be repeatably replayed using
        replayshell. Replayshell accurately models a Web page's structure by
        mirroring the page's server sharding.</p>
      </div>
      <div class="feature span3">
        <h2 class="callout">Use actual browsers</h2>
        <p>Recording and replaying sites can be done using commercial
        browsers such as Google Chrome, Mozilla Firefox, and Safari.
        It is recommended to use the same browser for recording and
        replaying. Using actual browsers more accurately represents
        user experience when loading Web pages.</p>
      </div>
      <div class="feature span3">
        <h2 class="callout">Directly compare transport protocols</h2>
        <p>A recorded site can be used to directly compare different
        transport protocols since the content and structure of each
        replayed Web page is identical. Replayshell's servers can be
        configured to handle different transport protocols using
        available Apache modules.</p>
      </div>
      <div class="feature span3">
        <h2 class="callout">Emulate numerous link conditions</h2>
        <p>Mahimahi can be used to emulate many different link conditions
        for replaying page loads or for a given program's traffic. Delayshell
        imposes a fixed minimum RTT on each incoming and outgoing packet.
        Cellshell is trace-based and can emulate time-varying links or
        fixed-rate links. Delayshell and Cellshell can be nested infinitely
        inside one another which enables many potential link emulations!</p>
      </div>
  </div>
  <div class="row-fluid">
      <div class="feature span3">
        <h2 class="callout">Lightweight (no effect on host)</h2>
        <p>Each of Mahimahi's tools is lightweight. It's network emulation
        tools (delayshell, cellshell) only add user-specified amounts of
        delay to traffic. Computation overhead is negligible. Fetching a
        Web object in replayshell represents the time to retrieve
        object of the infinitely-fast local interface.</p>
      </div>
      <div class="feature span3">
        <h2 class="callout">Quickly see effect of browser, Web page changes</h2>
        <p>A browser modification can be directly evaluated in replayshell
        by comparing page loads with and without the change, for the same recorded site.
        Similarly, modifications to a recorded Web page (eg. layout) can be evaluated
        by comparing page loads using the original and modified Web page.</p>
      </div>
  </div>
  </div>
</section>
      
<section id="news">
  <div class="page-header">
<section id="getting">
  <div class="page-header">
    <h1>Getting Mahimahi</h1>
  </div>

  <div id="binaries" class="row-fluid">
    <div class="span4" style="vertical-align: top;">
      <h3 class="callout"><a href="http://www.ubuntu.com"><img class="logo" src="ubuntu.png" alt=""></a>Ubuntu <small>13.04 and later</small></h3>
            <pre>$ sudo add-apt-repository ppa:keithw/mahimahi
$ sudo apt-get update
$ sudo apt-get install mahimahi</pre>
            <br />
    </div>
</div>
  <p><small>Operating system logos are trademarks or registered trademarks and are displayed for identification
only. The vendors shown aren't affiliated with and haven't endorsed Mahimahi.</small></p>

  <div id="build-instructions" class="page-header">
    <h2>Building from source</h2>
  </div>

  <div class="row-fluid">
    <div class="span8">
      <div class="row-fluid">
        <div class="span6">
          <!--<h3 class="callout">Compiling from Git</h3><br>-->
          <pre>$ git clone <a href="https://github.com/ravinet/mahimahi">https://github.com/ravinet/mahimahi</a>
$ cd mahimahi
$ ./autogen.sh
$ ./configure
$ make
# sudo make install</pre>
        </div>
      </div>
      <div class="row-fluid">
        <div class="span10">
          <h3 class="callout">Dependencies</h3><br>
          <table class="table table-striped" style="width: 100%;">
                  <thead><tr><th>Name</th><th>Typical package</th></tr></thead>
                  <tr class="deps"><td><a href="http://code.google.com/p/protobuf/">Protocol Buffers</a></td><td>protobuf-compiler, libprotobuf-dev</td></tr>
                  <tr><td>autotools</td><td>autotools-dev</td></tr>
                  <tr><td>autoreconf</td><td>dh-autoreconf</td></tr>
                  <tr><td>iptables</td><td>iptables</td></tr>
                  <tr><td>pkg-config</td><td>pkg-config</td></tr>
                  <tr><td>dnsmasq</td><td>dnsmasq</td></tr>
                  <tr><td>apache2</td><td>apache2</td></tr>
                  <tr><td>debhelper (7.0.50 or later)</td><td>debhelper</td></tr>
                  <tr><td>OpenSSL</td><td>libssl-dev, ssl-cert</td></tr>
          </table>
        </div>
      </div>
    </div>
    </div>
  </div>
</section>

<section id="techinfo">
  <div class="page-header">
    <h1>Details</h1>
  </div>
  
  <h2 class="callout">Delayshell</h2>

  <div class="row">
    <div class="span8">
  <p>
Delayshell uses clone() to fork off a new
shell in a distinct network namespace. All packets to and from an application running inside
delayshell are stored in a packet queue (one per direction). When a packet arrives at a queue, it is assigned a delivery time
which is the sum of its arrival time and a user-specified
fixed one-way delay. Packets are released from the queue at
their delivery time. This technique enforces a fixed delay on
a per-packet basis.
</p>
    </div>
  </div>

  <h2 class="callout">Cellshell</h2>

  <div class="row">
    <div class="span8">
  <p>
cellshell uses clone() to fork off a new shell in a distinct network namespace. Cellshell uses packet delivery traces to emulate
both time-varying links (eg. cellular) and fixed-rate links (eg. 12Mbps). When a packet
arrives at the link, it is directly placed into one of two packet queues
depending on its intended direction. cellshell releases packets from each queue based on the corresponding input
packet-delivery trace.

Cellshell interprets trace files such that each line in the trace
represents a packet delivery opportunity: the time at which 1500 bytes can be sent. Accounting is done at the byte-level.
Thus, a single line in the trace file can correspond
to the delivery of several packets whose sizes sum to 1500 bytes. Delivery opportunities are wasted if bytes are
unavailable at the instant of an opportunity. When cellshell reaches the end of an input trace file, it wraps
around to the beginning of the trace file and resets it's base timestamp value.
</p>
    </div>
  </div>


  <h2 class="callout">Recordshell</h2>

  <div class="row">
    <div class="span8">
  <p>
recordshell uses clone() to fork off a new shell in a distinct network namespace.
recordshell adds a routing table rule to forward all
TCP traffic from inside recordshell to a man-in-the-middle proxy.

The proxy accepts each TCP connection request from programs run inside recordshell.
It then determines the original destination address of the TCP connection request and connects to the original destination
on the program's behalf.

The proxy runs an HTTP parser which parses all TCP traffic to and from a program running in recordshell
to differentiate HTTP requests and responses from TCP segments. Once an HTTP request and its corresponding
response have been parsed, the proxy stores them as a request-response pair.

recordshell handles SSL traffic similarly using <a href="https://www.openssl.org/">OpenSSL</a>. To establish a connection with the program
running inside recordshell, the proxy uses a fake self-signed certificate
with the common name ’Mahimahi’. The proxy also makes an SSL connection request
to the original destination. Since a self signed certificate is used (it is not signed by a browser-trusted Certificate Authority),
the user must add an exception when loading a page in recordshell using HTTPS.

At the end of a recording session, the user-specified record folder consists of a
set of files: one for each request-response pair seen during
that recording session. Each file is stored using <a href="https://code.google.com/p/protobuf/">Google Protobufs</a> and includes
the complete HTTP request and response (headers and body) as well as
the connection's original destination ip address and port number, and
the protocol used (HTTP or HTTPS).recordshell is compatible with any unmodified browser because recording is done at the packet
level.

The figure below illustrates the actions taken by recordshell to record a Web page:
<p>1. Inside recordshell, a browser is used to load a Web page.</p>
<p>2. All HTTP requests from the browser are sent to the HTTP proxy running outside recordshell's isolated network namespace</p>
<p>3. These HTTP requests are sent to their original destinations in the Internet and the corresponding responses are sent back to the HTTP proxy</p>
<p>4. For each HTTP response received, the HTTP proxy sends the response back to the browser and sends the corresponding HTTP request-response pair to the Recorded site folder</p>
</p>
     <div class="span5"><img src="recordshell.png" style="max-width:120%;" HEIGHT="400" WIDTH="400" alt=""></img></div>

    </div>
  </div>

<h2 class="callout">Replayshell</h2>

  <div class="row">
    <div class="span8">
  <p>
replayshell uses unshare(CLONE_NEWNET) to create a shell in an
isolated network namespace. This isolation prevents the
accidental download of resources over the Internet when replaying page loads.

Unlike <a href="https://code.google.com/p/web-page-replay/">Google's Web-Page-Replay</a>, replayshell mimics the multi-origin nature of most web
sites today by creating an
Apache Web server for each distinct IP/port pair seen
while recording. This prevents the browser from using a single
TCP connection to download resources belonging to different
web servers (impossible due to the point-to-point nature of TCP).
replayshell binds its web servers to the same IP address and port number
as their recorded counterparts using dummy network interfaces.

All HTTP requests made within replayshell are handled by one
of replayshell's servers, each of which can access to the user-specified
recorded folder. Each server is configured to use a CGI script, called Replay Server,
which compares incoming HTTP requests to the set of all recorded request-response pairs to locate a matching HTTP response.
replayshell considers the Host, Accept-Language, Accept-Encoding, Connection,
and Referer HTTP header fields, and ignores time-sensitive header
fields (eg. If-Modified-Since, Cookie, If-Unmodified-Since) as they may change from run-to-run.
Replayshell handles query strings by first matching object names (ignoring query strings) and then finding the longest matched query string amongst the
matching object names. If an requested object has no match in the user-specified recorded folder,
Replay Server returns an HTTP "Connection: close".

Currently, replayshell supports HTTP and can be modified to support SPDY (using <a href="https://code.google.com/p/mod-spdy/">mod_spdy 0.9.3.3-386</a>).
HTTPS traffic is handled using <a href="http://httpd.apache.org/docs/2.2/mod/mod_ssl.html">Apache's mod_ssl</a>.

The figure below illustrates the actions taken by replayshell to replay a recorded Web page:
<p>1. Inside replayshell, a browser is used to load a recorded Web page.</p>
<p>2. Apache servers are set up inside the isolated network namespace to mimic the Web page's actual structure and sharding</p>
<p>3. All HTTP requests from the browser are sent to the appropriate Apache server (based on destination IP address)</p>
<p>4. The Apache servers each execute the Replay Server CGI script to handle incoming HTTP requests</p>
<p>5. Replay Server's have access to the recorded site and find the matching HTTP request and corresponding HTTP response</p>
<p>6. Apache server's send the matching HTTP response back to the browser</p>
</p>
     <div class="span5"><img src="replayshell.png" style="max-width:120%;" HEIGHT="400" WIDTH="400" alt=""></img></div>
    </div>
  </div>
</section>

<section id="usage">
  <div class="page-header">
    <h1>Example Commands</h1>
  </div>

  <div class="row">

    <div class="span4">
      <h3 class="callout">Emulating a link with 100ms minimum RTT</h3>
      <pre>$ delayshell <b>50</b></pre>
      <p>All programs run inside this shell will have a 100ms round-trip delay for all their packets</p>
    </div>

          <div class="span4">
            <h3 class="callout">Emulating a 12Mbps link</h3>
            <pre>$ cellshell <b>12Mbps_trace 12Mbps_trace</b></pre>
            <p>All programs run inside this shell will have their packets traverse the link according to the input trace files. Since the desired link is 12Mbps in each direction, the same trace file can be used for the uplink and downlink.</p>

            <p>To emulate a 12Mbps link, the trace file should increment each line by 1 (representing a millisecond between packet delivery opportunities). It should start with 0, 1,..., and be of any length because cellshell, upon reaching the end of a tracefile, continues from the beginning of the trace file</p>
          </div>

          <div class="span4">
            <h3 class="callout">Record a Web session into the /bome/recorded_site/ directory</h3>
            <pre>$ recordshell <b>/home/recorded_site/</b></pre>
            <p>All pages loaded from inside this shell will be recorded into /home/recorded_site/ as HTTP request/response pairs</p>
          </div>

        </div>

  <div class="row">

    <div class="span3">
      <h3 class="callout">Replay a Web session using the recorded content in /home/recorded_site/</h3>
      <pre>$ replayshell <b>/home/recorded_site/</b></pre>
      <p>All pages loaded when recording into "/home/recorded_site/" can be loaded from this shell. No other pages can be loaded.</p>
    </div>

    <div class="span9">
      <h3 class="callout">Replay a Web session using the recorded content in /home/recorded_site/ over an emulated 12Mbps link with 100ms minimum RTT</h3>
      <pre>$ delayshell <b>50</b></pre>
      <pre>[delay 10 ms] $ cellshell <b>12Mbps_trace 12Mbps_trace</b></pre>
      <pre>[delay 10 ms] [cell, up=12Mbps_trace.txt, down=12Mbps_trace.txt] $ replayshell <b>/home/recorded_site</b></pre>
      <p>All page loads from this inner-most shell will have their packets sent according to the input 12Mbps traces and delayed with a 100ms round-trip delay</p>
    </div>
  </div>



  <h3 class="callout">Exiting</h3>

  <p>To exit any shell, simply use <i>exit</i>. When nesting shells, <i>exit</i> will only exit the inner-most shell.</p>
  <p>You can verify that you have exited a given shell by checking that there is no prompt in the terminal (eg. [delay 10 ms] ).</p>

  <p>Replayshell has no prompt associated with it. To verify you have exited replayshell, you can use <i>ifconfig</i> and verify 
     that there are no network interfaces named "shardedX" (where X is is the sharded server's identification number). </p>
  

  <h3 class="callout">Manual</h3>

  <p>More details can be found in
  the <code>delayshell(1)</code>, <code>cellshell(1)</code>,
  <code>recordshell(1)</code>, and <code>replayshell(1)</code> manual pages.</p>

</section>

<section id="contact">
  <div class="page-header">
    <h1>Contact</h1>
  </div>
 <p>Mahimahi was written by Ravi Netravali, Anirudh Sivaraman, and Keith Winstein.</p>

  <p>For any questions or suggestions, please e-mail:</p>
  <div class="row">
  <div class="span8">
  <ul>
      <li><p><code>mahimahi@mit.edu</code><br>
      </ul>
    </div>
  </div>


</section>

    </div> <!-- /container -->

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="assets/js/jquery.js"></script>
    <script src="assets/js/bootstrap.min.js"></script>
  </body>
</html>
